<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTML 面试常见问题 | Weblog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/weblog/icon.png">
    <meta name="description" content="王贺楠的个人博客">
    
    <link rel="preload" href="/weblog/assets/css/0.styles.570b819f.css" as="style"><link rel="preload" href="/weblog/assets/js/app.eefccb8e.js" as="script"><link rel="preload" href="/weblog/assets/js/2.dbfb7c6a.js" as="script"><link rel="preload" href="/weblog/assets/js/37.580f62e9.js" as="script"><link rel="prefetch" href="/weblog/assets/js/10.f8c2c72b.js"><link rel="prefetch" href="/weblog/assets/js/11.d4e327d9.js"><link rel="prefetch" href="/weblog/assets/js/12.ee2dc6a7.js"><link rel="prefetch" href="/weblog/assets/js/13.a3a3b499.js"><link rel="prefetch" href="/weblog/assets/js/14.ead09c7e.js"><link rel="prefetch" href="/weblog/assets/js/15.f5c6f95a.js"><link rel="prefetch" href="/weblog/assets/js/16.04afe6fc.js"><link rel="prefetch" href="/weblog/assets/js/17.382c7d13.js"><link rel="prefetch" href="/weblog/assets/js/18.52eea6bd.js"><link rel="prefetch" href="/weblog/assets/js/19.30e45ce3.js"><link rel="prefetch" href="/weblog/assets/js/20.b8483ab0.js"><link rel="prefetch" href="/weblog/assets/js/21.3c184d9a.js"><link rel="prefetch" href="/weblog/assets/js/22.8af109a2.js"><link rel="prefetch" href="/weblog/assets/js/23.ed5c0b8a.js"><link rel="prefetch" href="/weblog/assets/js/24.14ea4201.js"><link rel="prefetch" href="/weblog/assets/js/25.1f3ae49b.js"><link rel="prefetch" href="/weblog/assets/js/26.674fa537.js"><link rel="prefetch" href="/weblog/assets/js/27.7708290f.js"><link rel="prefetch" href="/weblog/assets/js/28.253b6864.js"><link rel="prefetch" href="/weblog/assets/js/29.cf658570.js"><link rel="prefetch" href="/weblog/assets/js/3.f10b48a9.js"><link rel="prefetch" href="/weblog/assets/js/30.ecea30b5.js"><link rel="prefetch" href="/weblog/assets/js/31.353916dc.js"><link rel="prefetch" href="/weblog/assets/js/32.70c471b8.js"><link rel="prefetch" href="/weblog/assets/js/33.2046d5ff.js"><link rel="prefetch" href="/weblog/assets/js/34.d65fe706.js"><link rel="prefetch" href="/weblog/assets/js/35.1e4bba7e.js"><link rel="prefetch" href="/weblog/assets/js/36.c76be612.js"><link rel="prefetch" href="/weblog/assets/js/38.f7726144.js"><link rel="prefetch" href="/weblog/assets/js/39.1e2c12f4.js"><link rel="prefetch" href="/weblog/assets/js/4.89565c71.js"><link rel="prefetch" href="/weblog/assets/js/40.e1b6b8fe.js"><link rel="prefetch" href="/weblog/assets/js/41.e6433e8e.js"><link rel="prefetch" href="/weblog/assets/js/42.fb769ab0.js"><link rel="prefetch" href="/weblog/assets/js/43.b382479b.js"><link rel="prefetch" href="/weblog/assets/js/44.47622ca8.js"><link rel="prefetch" href="/weblog/assets/js/45.1387ff67.js"><link rel="prefetch" href="/weblog/assets/js/46.ea8e0fcf.js"><link rel="prefetch" href="/weblog/assets/js/47.6a9a93a1.js"><link rel="prefetch" href="/weblog/assets/js/48.76977a18.js"><link rel="prefetch" href="/weblog/assets/js/49.a157cbcb.js"><link rel="prefetch" href="/weblog/assets/js/5.7eff868e.js"><link rel="prefetch" href="/weblog/assets/js/50.9f0506b1.js"><link rel="prefetch" href="/weblog/assets/js/51.8586e26f.js"><link rel="prefetch" href="/weblog/assets/js/52.e307a1be.js"><link rel="prefetch" href="/weblog/assets/js/53.c582cf3c.js"><link rel="prefetch" href="/weblog/assets/js/54.03ed5fe7.js"><link rel="prefetch" href="/weblog/assets/js/55.23116427.js"><link rel="prefetch" href="/weblog/assets/js/56.4af49a61.js"><link rel="prefetch" href="/weblog/assets/js/57.6b889e18.js"><link rel="prefetch" href="/weblog/assets/js/58.f1f0a4ad.js"><link rel="prefetch" href="/weblog/assets/js/59.411b8fe9.js"><link rel="prefetch" href="/weblog/assets/js/6.372c6965.js"><link rel="prefetch" href="/weblog/assets/js/60.2759755d.js"><link rel="prefetch" href="/weblog/assets/js/61.1df9a14d.js"><link rel="prefetch" href="/weblog/assets/js/62.b7f33a0e.js"><link rel="prefetch" href="/weblog/assets/js/63.974dabb9.js"><link rel="prefetch" href="/weblog/assets/js/64.cca16d57.js"><link rel="prefetch" href="/weblog/assets/js/65.586e0e7f.js"><link rel="prefetch" href="/weblog/assets/js/66.48daa51a.js"><link rel="prefetch" href="/weblog/assets/js/67.57ad892a.js"><link rel="prefetch" href="/weblog/assets/js/68.ce0612cf.js"><link rel="prefetch" href="/weblog/assets/js/69.c1abdf8f.js"><link rel="prefetch" href="/weblog/assets/js/7.3ac9f8c9.js"><link rel="prefetch" href="/weblog/assets/js/70.5c27c9e0.js"><link rel="prefetch" href="/weblog/assets/js/71.22eef0c4.js"><link rel="prefetch" href="/weblog/assets/js/72.dc8d97ea.js"><link rel="prefetch" href="/weblog/assets/js/73.788e2dd1.js"><link rel="prefetch" href="/weblog/assets/js/74.d751f795.js"><link rel="prefetch" href="/weblog/assets/js/75.7918ac7c.js"><link rel="prefetch" href="/weblog/assets/js/76.107c27f5.js"><link rel="prefetch" href="/weblog/assets/js/77.c912c850.js"><link rel="prefetch" href="/weblog/assets/js/78.e23be5ae.js"><link rel="prefetch" href="/weblog/assets/js/79.cbeaa75a.js"><link rel="prefetch" href="/weblog/assets/js/8.775ec4e4.js"><link rel="prefetch" href="/weblog/assets/js/80.8c1da72a.js"><link rel="prefetch" href="/weblog/assets/js/81.e042d0c1.js"><link rel="prefetch" href="/weblog/assets/js/82.13420b1a.js"><link rel="prefetch" href="/weblog/assets/js/83.da010ed3.js"><link rel="prefetch" href="/weblog/assets/js/84.421e9b99.js"><link rel="prefetch" href="/weblog/assets/js/85.32c7e90a.js"><link rel="prefetch" href="/weblog/assets/js/9.0fb2fb12.js">
    <link rel="stylesheet" href="/weblog/assets/css/0.styles.570b819f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/weblog/" class="home-link router-link-active"><!----> <span class="site-name">Weblog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试" class="dropdown-title"><span class="title">面试</span> <span class="arrow down"></span></button> <button type="button" aria-label="面试" class="mobile-dropdown-title"><span class="title">面试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/weblog/html/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/weblog/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/weblog/javascript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/weblog/internet/" class="nav-link">
  网络
</a></li></ul></div></div><div class="nav-item"><a href="/weblog/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/weblog/webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/weblog/vue/design/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/weblog/typescript/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/weblog/git/" class="nav-link">
  Git基本使用
</a></div> <a href="https://github.com/wanghenan12138" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试" class="dropdown-title"><span class="title">面试</span> <span class="arrow down"></span></button> <button type="button" aria-label="面试" class="mobile-dropdown-title"><span class="title">面试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/weblog/html/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/weblog/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/weblog/javascript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/weblog/internet/" class="nav-link">
  网络
</a></li></ul></div></div><div class="nav-item"><a href="/weblog/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/weblog/webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/weblog/vue/design/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/weblog/typescript/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/weblog/git/" class="nav-link">
  Git基本使用
</a></div> <a href="https://github.com/wanghenan12138" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>HTML 面试常见问题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/weblog/html/#doctype-的作用是什么" class="sidebar-link">DOCTYPE 的作用是什么？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#标准模式与兼容模式各有什么区别" class="sidebar-link">标准模式与兼容模式各有什么区别？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#html5-为什么只需要写-而不需要引入-dtd" class="sidebar-link">HTML5 为什么只需要写 ，而不需要引入 DTD？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#行内元素定义" class="sidebar-link">行内元素定义</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#块级元素定义" class="sidebar-link">块级元素定义</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#行内元素与块级元素的区别" class="sidebar-link">行内元素与块级元素的区别？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#html5-元素的分类" class="sidebar-link">HTML5 元素的分类</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#空元素定义" class="sidebar-link">空元素定义</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#link-标签定义" class="sidebar-link">link 标签定义</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#页面导入样式时-使用-link-和-import-有什么区别" class="sidebar-link">页面导入样式时，使用 link 和 @import 有什么区别？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#介绍一下你对浏览器内核的理解" class="sidebar-link">介绍一下你对浏览器内核的理解？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#浏览器的渲染原理" class="sidebar-link">浏览器的渲染原理？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#渲染过程中遇到-js-文件怎么处理-浏览器解析过程" class="sidebar-link">渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#async-和-defer-的作用是什么-有什么区别-浏览器解析过程" class="sidebar-link">async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#什么是文档的预解析-浏览器解析过程" class="sidebar-link">什么是文档的预解析？（浏览器解析过程）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#css-如何阻塞文档解析-浏览器解析过程" class="sidebar-link">CSS 如何阻塞文档解析？（浏览器解析过程）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#渲染页面时常见哪些不良现象-浏览器渲染过程" class="sidebar-link">渲染页面时常见哪些不良现象？（浏览器渲染过程）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#如何优化关键渲染路径-浏览器渲染过程" class="sidebar-link">如何优化关键渲染路径？（浏览器渲染过程）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#什么是重绘和回流-浏览器绘制过程" class="sidebar-link">什么是重绘和回流？（浏览器绘制过程）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#如何减少回流-浏览器绘制过程" class="sidebar-link">如何减少回流？（浏览器绘制过程）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#domcontentloaded-事件和-load-事件的区别" class="sidebar-link">DOMContentLoaded 事件和 Load 事件的区别？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#html5-有哪些新特性、移除了那些元素" class="sidebar-link">HTML5 有哪些新特性、移除了那些元素？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#如何处理-html5-新标签的浏览器兼容问题" class="sidebar-link">如何处理 HTML5 新标签的浏览器兼容问题？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#简述一下你对-html-语义化的理解" class="sidebar-link">简述一下你对 HTML 语义化的理解？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#前端需要注意哪些-seo" class="sidebar-link">前端需要注意哪些 SEO ？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#浏览器是怎么对-html5-的离线储存资源进行管理和加载的呢" class="sidebar-link">浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#请描述一下-cookies-sessionstorage-和-localstorage-的区别" class="sidebar-link">请描述一下 cookies，sessionStorage 和 localStorage 的区别？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#iframe-有那些缺点" class="sidebar-link">iframe 有那些缺点？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#label-的作用是什么-是怎么用的" class="sidebar-link">Label 的作用是什么？是怎么用的？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#html5-的-form-的自动完成功能是什么" class="sidebar-link">HTML5 的 form 的自动完成功能是什么？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#如何实现浏览器内多个标签页之间的通信" class="sidebar-link">如何实现浏览器内多个标签页之间的通信?</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#websocket-如何兼容低版本浏览器" class="sidebar-link">webSocket 如何兼容低版本浏览器？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#页面可见性-page-visibility-api-可以有哪些用途" class="sidebar-link">页面可见性（Page Visibility API） 可以有哪些用途？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#如何在页面上实现一个圆形的可点击区域" class="sidebar-link">如何在页面上实现一个圆形的可点击区域？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#实现不使用-border-画出-1-px-高的线-在不同浏览器的标准模式与怪异模式下都能保持一致的效果。" class="sidebar-link">实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#title-与-h1-的区别" class="sidebar-link">title 与 h1 的区别？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#的-title-和-alt-有什么区别" class="sidebar-link">的 title 和 alt 有什么区别？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#canvas-和-svg-有什么区别" class="sidebar-link">Canvas 和 SVG 有什么区别？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#网页验证码是干嘛的-是为了解决什么安全问题" class="sidebar-link">网页验证码是干嘛的，是为了解决什么安全问题？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#渐进增强和优雅降级的定义" class="sidebar-link">渐进增强和优雅降级的定义</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#attribute-和-property-的区别是什么" class="sidebar-link">attribute 和 property 的区别是什么？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#对-web-标准、可用性、可访问性的理解" class="sidebar-link">对 web 标准、可用性、可访问性的理解</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#ie-各版本和-chrome-可以并行下载多少个资源" class="sidebar-link">IE 各版本和 Chrome 可以并行下载多少个资源？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#flash、ajax-各自的优缺点-在使用中如何取舍" class="sidebar-link">Flash、Ajax 各自的优缺点，在使用中如何取舍？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#css-reset-和-normalize-css-有什么区别" class="sidebar-link">css reset 和 normalize.css 有什么区别？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#dhtml-是什么" class="sidebar-link">DHTML 是什么？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#head-标签中必不少的是" class="sidebar-link">head 标签中必不少的是？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#html5-新增的表单元素有" class="sidebar-link">HTML5 新增的表单元素有？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#在-html5-中-哪个方法用于获得用户的当前位置" class="sidebar-link">在 HTML5 中，哪个方法用于获得用户的当前位置？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#disabled-和-readonly-的区别" class="sidebar-link">disabled 和 readonly 的区别？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#前端性能优化" class="sidebar-link">前端性能优化？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#扫描二维码登录网页是什么原理-前后两个事件是如何联系的" class="sidebar-link">扫描二维码登录网页是什么原理，前后两个事件是如何联系的？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/weblog/html/#html-规范中为什么要求引用资源不加协议头http或者https" class="sidebar-link">Html 规范中为什么要求引用资源不加协议头http或者https？</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="html-面试常见问题"><a href="#html-面试常见问题" class="header-anchor">#</a> HTML 面试常见问题</h1> <h2 id="doctype-的作用是什么"><a href="#doctype-的作用是什么" class="header-anchor">#</a> DOCTYPE 的作用是什么？</h2> <p><code>IE5.5</code> 引入了文档模式的概念，而这个概念是通过使用文档类型<code>（DOCTYPE）</code>切换实现的。
<code>&lt;!DOCTYPE&gt;</code>声明位于 <code>HTML</code> 文档中的第一行，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。
<code>DOCTYPE</code> 不存在或格式不正确会导致文档以兼容模式呈现。</p> <p><code>&lt;!DOCTYPE&gt;</code>  声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来
进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏
览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。</p> <p>在 <code>html5</code> 之后不再需要指定 <code>DTD</code> 文档，因为 <code>html5</code> 以前的 <code>html</code> 文档都是基于 <code>SGML</code> 的，所以需要通过指定 <code>DTD</code> 来定义文
档中允许的属性以及一些规则。而 <code>html5</code> 不再基于 <code>SGML</code> 了，所以不再需要使用 <code>DTD</code>。</p> <h2 id="标准模式与兼容模式各有什么区别"><a href="#标准模式与兼容模式各有什么区别" class="header-anchor">#</a> 标准模式与兼容模式各有什么区别？</h2> <p>标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示
，模拟老式浏览器的行为以防止站点无法工作。</p> <h2 id="html5-为什么只需要写-而不需要引入-dtd"><a href="#html5-为什么只需要写-而不需要引入-dtd" class="header-anchor">#</a> HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;，而不需要引入 DTD？</h2> <p><code>HTML5</code> 不基于 <code>SGML</code>，因此不需要对 <code>DTD</code> 进行引用，但是需要 <code>DOCTYPE</code> 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。
而 <code>HTML4.01</code> 基于 <code>SGML</code> ，所以需要对 <code>DTD</code> 进行引用，才能告知浏览器文档所使用的文档类型。</p> <h2 id="行内元素定义"><a href="#行内元素定义" class="header-anchor">#</a> 行内元素定义</h2> <p>HTML4 中，元素被分成两大类: <code>inline</code> （内联元素）与 <code>block</code>（块级元素）。一个行内元素只占据它对应标签的边框所包含的空间。<br>
常见的行内元素有 <code>a b span img strong sub sup button input label select textarea</code></p> <h2 id="块级元素定义"><a href="#块级元素定义" class="header-anchor">#</a> 块级元素定义</h2> <p>块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。<br>
常见的块级元素有  <code>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</code></p> <h2 id="行内元素与块级元素的区别"><a href="#行内元素与块级元素的区别" class="header-anchor">#</a> 行内元素与块级元素的区别？</h2> <p><code>HTML4</code>中，元素被分成两大类：<code>inline</code> （内联元素）与 <code>block</code> （块级元素）。<br>
（1） 格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。<br>
（2） 内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。<br>
（3） 行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 <code>width</code> 无效，<code>height</code> 无效（可以设置 <code>line-height</code>），设置 <code>margin</code> 和 <code>padding</code> 的上下不会对其他元素产生影响。</p> <h2 id="html5-元素的分类"><a href="#html5-元素的分类" class="header-anchor">#</a> HTML5 元素的分类</h2> <p><code>HTML4</code>中，元素被分成两大类: <code>inline</code>（内联元素）与 <code>block</code>（块级元素）。但在实际的开发过程中，因为页面表现的需要，前端工程师经常把 <code>inline</code> 元素的 <code>display</code> 值设定为 <code>block</code> （比如 <code>a</code> 标签），也经常把 <code>block</code> 元素的 <code>display</code> 值设定为<code>inline</code> 之后更是出现了 <code>inline-block</code> 这一对外呈现 <code>inline</code> 对内呈现 <code>block</code> 的属性。因此，简单地把 <code>HTML</code>元素划分<code>inline</code> 与 <code>block</code> 已经不再符合实际需求。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><code>HTML5</code>中，元素主要分为7类：<code>Metadata Flow Sectioning Heading Phrasing Embedded Interactive</code></p></div> <h2 id="空元素定义"><a href="#空元素定义" class="header-anchor">#</a> 空元素定义</h2> <p>标签内没有内容的 <code>HTML</code> 标签被称为空元素。空元素是在开始标签中关闭的。<br>
常见的空元素有：<code>br hr img input link meta</code></p> <h2 id="link-标签定义"><a href="#link-标签定义" class="header-anchor">#</a> link 标签定义</h2> <p><code>link</code> 标签定义文档与外部资源的关系。
<code>link</code> 元素是空元素，它仅包含属性。 此元素只能存在于 head 部分，不过它可出现任何次数。
<code>link</code> 标签中的 <code>rel</code> 属性定义了当前文档与被链接文档之间的关系。常见的 <code>stylesheet</code> 指的是定义一个外部加载的样式表。</p> <h2 id="页面导入样式时-使用-link-和-import-有什么区别"><a href="#页面导入样式时-使用-link-和-import-有什么区别" class="header-anchor">#</a> 页面导入样式时，使用 link 和 @import 有什么区别？</h2> <p>（1）从属关系区别。 <code>@import</code> 是 CSS 提供的语法规则，只有导入样式表的作用；<code>link</code>是 HTML 提供的标签，不仅可以加载 CSS 文件，还可以定义 <code>RSS、rel</code> 连接属性、引入网站图标等。<br>
（2）加载顺序区别。加载页面时，<code>link</code> 标签引入的 CSS 被同时加载；<code>@import</code> 引入的 CSS 将在页面加载完毕后被加载。<br>
（3）兼容性区别。<code>@import</code> 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；<code>link</code> 标签作为 HTML 元素，不存在兼容性问题。<br>
（4）DOM 可控性区别。可以通过 <code>JS</code> 操作 <code>DOM</code> ，插入 <code>link</code> 标签来改变样式；由于 DOM 方法是基于文档的，无法使用 <code>@import</code> 的方式插入样式。</p> <h2 id="介绍一下你对浏览器内核的理解"><a href="#介绍一下你对浏览器内核的理解" class="header-anchor">#</a> 介绍一下你对浏览器内核的理解？</h2> <p>主要分成两部分：<code>渲染引擎</code>和 <code>JS 引擎</code>。<br>
渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 <code>html、xml</code> 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。<br> <code>JS 引擎</code>：解析和执行 <code>javascript</code> 来实现网页的动态效果。<br>
最开始<code>渲染引擎</code>和 <code>JS 引擎</code>并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p> <h2 id="浏览器的渲染原理"><a href="#浏览器的渲染原理" class="header-anchor">#</a> 浏览器的渲染原理？</h2> <p>（1）首先解析收到的文档，根据文档定义构建一棵 <code>DOM 树</code>，<code>DOM 树</code>是由 <code>DOM 元素</code>及属性节点组成的。<br>
（2）然后对 <code>CSS</code> 进行解析，生成 <code>CSSOM</code> 规则树。<br>
（3）根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。<br>
（4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。<br>
（5）布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 <code>paint 方法</code>将它们的内容显示在屏幕上，绘制使用 <code>UI 基础组件</code>。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p></div> <h2 id="渲染过程中遇到-js-文件怎么处理-浏览器解析过程"><a href="#渲染过程中遇到-js-文件怎么处理-浏览器解析过程" class="header-anchor">#</a> 渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）</h2> <p><code>JavaScript</code> 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 <code>DOM</code> 时，<code>HTML 解析器</code>若遇到了 <code>JavaScript</code>，那么它会暂停文档的解析，将控制权移交给 <code>JavaScript 引擎</code>，等 <code>JavaScript</code> 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。<br>
也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将<code>script</code>标签放在 <code>body</code> 标签底部的原因。当然在当下，并不是说 <code>script</code> 标签必须放在底部，因为你可以给 <code>script</code> 标签添加 <code>defer</code> 或者 <code>async</code> 属性。</p> <h2 id="async-和-defer-的作用是什么-有什么区别-浏览器解析过程"><a href="#async-和-defer-的作用是什么-有什么区别-浏览器解析过程" class="header-anchor">#</a> async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）</h2> <p>（1）脚本没有 <code>defer</code> 或 <code>async</code>，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。<br>
（2）<code>defer</code> 属性表示延迟执行引入的 <code>JavaScript</code>，即这段 <code>JavaScript</code> 加载时 <code>HTML</code> 并未停止解析，这两个过程是并行的。当整个 <code>document</code> 解析完毕后再执行脚本文件，在 <code>DOMContentLoaded</code> 事件触发之前完成。多个脚本按顺序执行。<br>
（3）<code>async</code> 属性表示异步执行引入的 <code>JavaScript</code>，与 <code>defer</code> 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。</p> <h2 id="什么是文档的预解析-浏览器解析过程"><a href="#什么是文档的预解析-浏览器解析过程" class="header-anchor">#</a> 什么是文档的预解析？（浏览器解析过程）</h2> <p><code>Webkit</code> 和 <code>Firefox</code> 都做了这个优化，当执行 <code>JavaScript</code> 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 <code>DOM 树</code>，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p> <h2 id="css-如何阻塞文档解析-浏览器解析过程"><a href="#css-如何阻塞文档解析-浏览器解析过程" class="header-anchor">#</a> CSS 如何阻塞文档解析？（浏览器解析过程）</h2> <p>理论上，既然样式表不改变 <code>DOM 树</code>，也就没有必要停下文档的解析等待它们，然而，存在一个问题，<code>JavaScript</code> 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。<br>
所以如果浏览器尚未完成 <code>CSSOM</code> 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 <code>JavaScript</code> 脚本执行和文档的解析，直至其完成 <code>CSSOM</code> 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 <code>CSSOM</code>，然后再执行 <code>JavaScript</code>，最后再继续文档的解析。</p> <h2 id="渲染页面时常见哪些不良现象-浏览器渲染过程"><a href="#渲染页面时常见哪些不良现象-浏览器渲染过程" class="header-anchor">#</a> 渲染页面时常见哪些不良现象？（浏览器渲染过程）</h2> <p><code>FOUC</code>：主要指的是样式闪烁的问题，由于浏览器渲染机制（比如firefox），在 <code>CSS</code> 加载之前，先呈现了 <code>HTML</code>，就会导致展示出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 <code>css</code>加载时间过长，或者 <code>css</code> 被放在了文档底部。<br> <code>白屏</code>：有些浏览器渲染机制（比如chrome）要先构建 <code>DOM</code> 树和 <code>CSSOM</code> 树，构建完成后再进行渲染，如果 <code>CSS</code> 部分放在 <code>HTML</code>尾部，由于 <code>CSS</code> 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 <code>js</code> 文件放在头部，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。</p> <h2 id="如何优化关键渲染路径-浏览器渲染过程"><a href="#如何优化关键渲染路径-浏览器渲染过程" class="header-anchor">#</a> 如何优化关键渲染路径？（浏览器渲染过程）</h2> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：<br>
（1）关键资源的数量。<br>
（2）关键路径长度。<br>
（3）关键字节的数量。</p></div> <p>关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 <code>CPU</code> 以及其他资源的占用也就越少。<br>
同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。</p> <p>最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p> <p>优化关键渲染路径的常规步骤如下：</p> <p>（1）对关键路径进行分析和特性描述：资源数、字节数、长度。<br>
（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。<br>
（3）优化关键字节数以缩短下载时间（往返次数）。<br>
（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。</p> <h2 id="什么是重绘和回流-浏览器绘制过程"><a href="#什么是重绘和回流-浏览器绘制过程" class="header-anchor">#</a> 什么是重绘和回流？（浏览器绘制过程）</h2> <p>重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 <code>background-color</code>，我们将这样的操作称为重绘。<br>
回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。</p> <p>常见引起回流属性和方法：<br>
任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。<br>
（1）添加或者删除可见的 <code>DOM</code> 元素；<br>
（2）元素尺寸改变——边距、填充、边框、宽度和高度<br>
（3）内容变化，比如用户在 <code>input</code> 框中输入文字<br>
（4）浏览器窗口尺寸改变——<code>resize</code>事件发生时<br>
（5）计算 <code>offsetWidth</code> 和 <code>offsetHeight</code> 属性<br>
（6）设置 <code>style</code> 属性的值<br>
（7）当你修改网页的默认字体时。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p></div> <h2 id="如何减少回流-浏览器绘制过程"><a href="#如何减少回流-浏览器绘制过程" class="header-anchor">#</a> 如何减少回流？（浏览器绘制过程）</h2> <p>（1）使用 <code>transform</code> 替代 <code>top</code><br>
（2）不要把节点的属性值放在一个循环里当成循环里的变量<br>
（3）不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局<br>
（4）把 DOM 离线后修改。如：使用 <code>documentFragment</code> 对象在内存里操作 DOM<br>
（5）不要一条一条地修改 <code>DOM</code> 的样式。与其这样，还不如预先定义好 <code>css</code> 的 <code>class</code>，然后修改 <code>DOM</code> 的 <code>className</code></p> <h2 id="domcontentloaded-事件和-load-事件的区别"><a href="#domcontentloaded-事件和-load-事件的区别" class="header-anchor">#</a> DOMContentLoaded 事件和 Load 事件的区别？</h2> <p>当初始的 <code>HTML</code> 文档被完全加载和解析完成之后，<code>DOMContentLoaded</code> 事件被触发，而无需等待样式表、图像和子框架的加载完成。<br> <code>Load</code> 事件是当所有资源加载完成后触发的。</p> <h2 id="html5-有哪些新特性、移除了那些元素"><a href="#html5-有哪些新特性、移除了那些元素" class="header-anchor">#</a> HTML5 有哪些新特性、移除了那些元素？</h2> <p><code>HTML5</code> 现在已经不是 <code>SGML</code> 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p> <p>新增的有：</p> <p>绘画 <code>canvas</code><br>
用于媒介回放的 <code>video</code> 和 <code>audio</code> 元素<br>
本地离线存储 <code>localStorage</code> 长期存储数据，浏览器关闭后数据不丢失<br> <code>sessionStorage</code> 的数据在浏览器关闭后自动删除<br>
语意化更好的内容元素，比如 <code>article、footer、header、nav、section</code><br>
表单控件，<code>calendar、date、time、email、url、search</code><br>
新的技术 <code>webworker</code>, <code>websocket</code><br>
新的文档属性 <code>document.visibilityState</code></p> <p>移除的元素有：</p> <p>纯表现的元素：<code>basefont，big，center，font, s，strike，tt，u</code><br>
对可用性产生负面影响的元素：<code>frame，frameset，noframes</code></p> <h2 id="如何处理-html5-新标签的浏览器兼容问题"><a href="#如何处理-html5-新标签的浏览器兼容问题" class="header-anchor">#</a> 如何处理 HTML5 新标签的浏览器兼容问题？</h2> <p><code>IE8/IE7/IE6</code> 支持通过 <code>document.createElement</code> 方法产生的标签，可以利用这一特性让这些浏览器支持 <code>HTML5</code> 新标签，浏览器支持新标签后，还需要添加标签默认的样式。<br>
当然也可以直接使用成熟的框架，比如 html5shiv ;</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!--[if lt IE 9]&gt;
	&lt;script&gt; src=&quot;https://cdn.jsdelivr.net/npm/html5shiv/dist/html5shiv.min.js&quot;&lt;/script&gt;
&lt;![endif]--&gt;</span>
</code></pre></div><p><code>[if lte IE 9]……[endif]</code> 判断 IE 的版本，限定只有 IE9 以下浏览器版本需要执行的语句。</p> <h2 id="简述一下你对-html-语义化的理解"><a href="#简述一下你对-html-语义化的理解" class="header-anchor">#</a> 简述一下你对 HTML 语义化的理解？</h2> <p>（1） 用正确的标签做正确的事情。<br>
（2） <code>html</code> 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;<br>
（3） 即使在没有样式 <code>CSS</code> 情况下也以一种文档格式显示，并且是容易阅读的;<br>
（4） 搜索引擎的爬虫也依赖于 <code>HTML</code> 标记来确定上下文和各个关键字的权重，利于 <code>SEO</code> ;<br>
（5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p> <h2 id="前端需要注意哪些-seo"><a href="#前端需要注意哪些-seo" class="header-anchor">#</a> 前端需要注意哪些 SEO ？</h2> <p>（1）合理的 <code>title、description、keywords</code>：搜索对着三项的权重逐个减小，<code>title</code> 值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面 <code>title</code> 要有所不同；<code>description</code> 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 <code>description</code> 有所不同；<code>keywords</code> 列举出重要关键词即可。<br>
（2）语义化的 <code>HTML</code> 代码，符合 <code>W3C</code> 规范：语义化代码让搜索引擎容易理解网页。<br>
（3）重要内容 <code>HTML</code> 代码放在最前：搜索引擎抓取 <code>HTML</code> 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被抓取。<br>
（4）重要内容不要用 <code>js</code> 输出：爬虫不会执行 <code>js</code> 获取内容<br>
（5）少用 <code>iframe</code>：搜索引擎不会抓取 <code>iframe</code> 中的内容<br>
（6）非装饰性图片必须加 <code>alt</code>
（7）提高网站速度：网站速度是搜索引擎排序的一个重要指标</p> <h2 id="浏览器是怎么对-html5-的离线储存资源进行管理和加载的呢"><a href="#浏览器是怎么对-html5-的离线储存资源进行管理和加载的呢" class="header-anchor">#</a> 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？</h2> <p>在线的情况下，浏览器发现 <code>html</code> 头部有 <code>manifest</code> 属性，它会请求 <code>manifest</code> 文件，如果是第一次访问app ，那么浏览器就会根据 <code>manifest</code> 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 <code>manifest</code> 文件与旧的 <code>manifest</code> 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</p> <p>离线的情况下，浏览器就直接使用离线存储的资源。</p> <h2 id="请描述一下-cookies-sessionstorage-和-localstorage-的区别"><a href="#请描述一下-cookies-sessionstorage-和-localstorage-的区别" class="header-anchor">#</a> 请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h2> <p>浏览器端常用的存储技术是 <code>cookie</code> 、<code>localStorage</code> 和 <code>sessionStorage</code>。</p> <p><code>cookie</code> 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。<code>cookie</code> 最多能存储 <code>4 k</code> 数据，它的生存时间由 <code>expires</code> 属性指定，并且 <code>cookie</code> 只能被同源的页面访问共享。</p> <p><code>sessionStorage</code> 是 <code>html5</code> 提供的一种浏览器本地存储的方法，它借鉴了服务器端 <code>session</code> 的概念，代表的是一次会话中所保存的数据。它一般能够存储 <code>5M</code> 或者更大的数据，它在当前窗口关闭后就失效,<code>sessionStorage</code> 只能被同一个窗口的同源页面所访问共享。</p> <p><code>localStorage</code> 也是 <code>html5</code> 提供的一种浏览器本地存储的方法，它一般也能够存储 <code>5M</code> 或者更大的数据。它和 <code>sessionStorage</code>不同的是，除非手动删除它，否则它不会失效，并且 <code>localStorage</code> 也只能被同源页面所访问共享。</p> <p>上面几种方式都是存储少量数据的时候的存储方式，当我们需要在本地存储大量数据的时候，我们可以使用浏览器的 <code>indexDB</code> 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 <code>NoSQL</code>数据库。</p> <h2 id="iframe-有那些缺点"><a href="#iframe-有那些缺点" class="header-anchor">#</a> iframe 有那些缺点？</h2> <p><code>iframe</code> 元素会创建包含另外一个文档的内联框架（即行内框架）。</p> <p>主要缺点有：</p> <p>（1） <code>iframe</code> 会阻塞主页面的 <code>onload</code> 事件。<code>window</code> 的 <code>onload</code> 事件需要在所有 <code>iframe</code> 加载完毕后（包含里面的元素）才会触发。在 <code>Safari</code> 和 <code>Chrome</code> 里，通过 <code>JavaScript</code> 动态设置 <code>iframe</code> 的 <code>src</code> 可以避免这种阻塞情况。<br>
（2） 搜索引擎的检索程序无法解读这种页面，不利于网页的 <code>SEO</code> 。<br>
（3） <code>iframe</code> 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。<br>
（4） 浏览器的后退按钮失效。<br>
（5） 小型的移动设备无法完全显示框架。</p> <h2 id="label-的作用是什么-是怎么用的"><a href="#label-的作用是什么-是怎么用的" class="header-anchor">#</a> Label 的作用是什么？是怎么用的？</h2> <p><code>label</code> 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Name<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Number:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>“text“</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Name<span class="token punctuation">&quot;</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Name<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><h2 id="html5-的-form-的自动完成功能是什么"><a href="#html5-的-form-的自动完成功能是什么" class="header-anchor">#</a> HTML5 的 form 的自动完成功能是什么？</h2> <p><code>autocomplete</code> 属性规定输入字段是否应该启用自动完成功能。默认为启用，设置为 <code>autocomplete=off</code> 可以关闭该功能。</p> <p>自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。</p> <p><code>autocomplete</code> 属性适用于 <code>&lt;form&gt;</code>，以及下面的 <code>&lt;input&gt;</code> 类型：<code>text, search, url, telephone, email, password, datepickers, range 以及 color</code>。</p> <h2 id="如何实现浏览器内多个标签页之间的通信"><a href="#如何实现浏览器内多个标签页之间的通信" class="header-anchor">#</a> 如何实现浏览器内多个标签页之间的通信?</h2> <p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。</p> <p>第一种实现的方式是使用 <code>websocket</code> 协议，因为 <code>websocket</code> 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。
标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</p> <p>第二种是使用 <code>ShareWorker</code> 的方式，<code>shareWorker</code> 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。</p> <p>第三种方式是使用 <code>localStorage</code> 的方式，我们可以在一个标签页对 <code>localStorage</code> 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 <code>localStorage</code> 对象就是充当的中介者的角色。</p> <p>还有一种方式是使用 <code>postMessage</code> 方法，如果我们能够获得对应标签页的引用，我们就可以使用 <code>postMessage</code> 方法，进行通信。</p> <h2 id="websocket-如何兼容低版本浏览器"><a href="#websocket-如何兼容低版本浏览器" class="header-anchor">#</a> webSocket 如何兼容低版本浏览器？</h2> <p><code>Adobe Flash Socket</code><br> <code>ActiveX HTMLFile (IE)</code><br> <code>基于 multipart 编码发送 XHR</code><br> <code>基于长轮询的 XHR</code></p> <h2 id="页面可见性-page-visibility-api-可以有哪些用途"><a href="#页面可见性-page-visibility-api-可以有哪些用途" class="header-anchor">#</a> 页面可见性（Page Visibility API） 可以有哪些用途？</h2> <p>这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户不看网页，下面这些网页行为都是可以暂停的。</p> <p>（1）对服务器的轮询<br>
（2）网页动画<br>
（3）正在播放的音频或视频</p> <h2 id="如何在页面上实现一个圆形的可点击区域"><a href="#如何在页面上实现一个圆形的可点击区域" class="header-anchor">#</a> 如何在页面上实现一个圆形的可点击区域？</h2> <p>（1）纯 <code>html</code> 实现，使用 <code>&lt;area&gt;</code> 来给 <code>&lt;img&gt;</code> 图像标记热点区域的方式，<code>&lt;map&gt;</code> 标签用来定义一个客户端图像映射，<code>&lt;area&gt;</code> 标签用来定义图像映射中的区域，<code>area</code> 元素永远嵌套在 <code>map</code> 元素内部，我们可以将 <code>area</code> 区域设置为圆形，从而实现可点击的圆形区域。</p> <p>（2）纯 <code>css</code> 实现，使用 <code>border-radius</code> ，当 <code>border-radius</code> 的长度等于宽高相等的元素值的一半时，即可实现一个圆形的点击区域。</p> <p>（3）纯 <code>js</code> 实现，判断一个点在不在圆上的简单算法，通过监听文档的点击事件，获取每次点击时鼠标的位置，判断该位置是否在我们规定的圆形区域内。</p> <h2 id="实现不使用-border-画出-1-px-高的线-在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"><a href="#实现不使用-border-画出-1-px-高的线-在不同浏览器的标准模式与怪异模式下都能保持一致的效果。" class="header-anchor">#</a> 实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</h2> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token style language-css"><span class="token property">height</span><span class="token punctuation">:</span>1px<span class="token punctuation">;</span><span class="token property">overflow</span><span class="token punctuation">:</span>hidden<span class="token punctuation">;</span><span class="token property">background</span><span class="token punctuation">:</span>red</span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="title-与-h1-的区别"><a href="#title-与-h1-的区别" class="header-anchor">#</a> title 与 h1 的区别？</h2> <p><code>title</code> 属性没有明确意义只表示是个标题，<code>h1</code> 则表示层次明确的标题，对页面信息的抓取也有很大的影响。</p> <h2 id="的-title-和-alt-有什么区别"><a href="#的-title-和-alt-有什么区别" class="header-anchor">#</a> <img> 的 title 和 alt 有什么区别？</h2> <p><code>title</code> 通常当鼠标滑动到元素上的时候显示</p> <p><code>alt</code> 是 <code>&lt;img&gt;</code> 的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</p> <h2 id="canvas-和-svg-有什么区别"><a href="#canvas-和-svg-有什么区别" class="header-anchor">#</a> Canvas 和 SVG 有什么区别？</h2> <p><code>Canvas</code> 是一种通过 <code>JavaScript</code> 来绘制 <code>2D 图形</code>的方法。<code>Canvas</code> 是逐像素来进行渲染的，因此当我们对 <code>Canvas</code> 进行缩放时，会出现锯齿或者失真的情况。</p> <p><code>SVG</code> 是一种使用 <code>XML</code> 描述 <code>2D 图形</code>的语言。<code>SVG</code> 基于 <code>XML</code>，这意味着 <code>SVG DOM</code> 中的每个元素都是可用的。我们可以为某个元素附加 <code>JavaScript</code> 事件监听函数。并且 <code>SVG</code> 保存的是图形的绘制方法，因此当 <code>SVG</code> 图形缩放时并不会失真。</p> <h2 id="网页验证码是干嘛的-是为了解决什么安全问题"><a href="#网页验证码是干嘛的-是为了解决什么安全问题" class="header-anchor">#</a> 网页验证码是干嘛的，是为了解决什么安全问题？</h2> <p>（1）区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水<br>
（2）有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</p> <h2 id="渐进增强和优雅降级的定义"><a href="#渐进增强和优雅降级的定义" class="header-anchor">#</a> 渐进增强和优雅降级的定义</h2> <p>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。<br>
优雅降级：一开始就根据高版本浏览器构建完整的功能，然后再针对低版本浏览器进行兼容。</p> <h2 id="attribute-和-property-的区别是什么"><a href="#attribute-和-property-的区别是什么" class="header-anchor">#</a> attribute 和 property 的区别是什么？</h2> <p><code>attribute</code>是 <code>dom</code> 元素在文档中作为 <code>html</code>标签拥有的属性；<br> <code>property</code> 就是 <code>dom</code> 元素在 <code>js</code> 中作为对象拥有的属性。<br>
对于 <code>html</code> 的标准属性来说，<code>attribute</code> 和 <code>property</code> 是同步的，是会自动更新的，<br>
但是对于自定义的属性来说，他们是不同步的。</p> <h2 id="对-web-标准、可用性、可访问性的理解"><a href="#对-web-标准、可用性、可访问性的理解" class="header-anchor">#</a> 对 web 标准、可用性、可访问性的理解</h2> <p><code>可用性（Usability</code>）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力</p> <p><code>可访问性（Accessibility）</code>：Web 内容对于残障用户的可阅读和可理解性</p> <p><code>可维护性（Maintainability）</code>：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。</p> <h2 id="ie-各版本和-chrome-可以并行下载多少个资源"><a href="#ie-各版本和-chrome-可以并行下载多少个资源" class="header-anchor">#</a> IE 各版本和 Chrome 可以并行下载多少个资源？</h2> <p>（1）  <code>IE6</code>2 个并发<br>
（2）  <code>iE7</code> 升级之后的 6 个并发，之后版本也是 6 个<br>
（3）  <code>Firefox</code>，<code>chrome</code> 也是6个</p> <h2 id="flash、ajax-各自的优缺点-在使用中如何取舍"><a href="#flash、ajax-各自的优缺点-在使用中如何取舍" class="header-anchor">#</a> Flash、Ajax 各自的优缺点，在使用中如何取舍？</h2> <p><code>Flash</code>：<br>
（1） <code>Flash</code> 适合处理多媒体、矢量图形、访问机器<br>
（2） 对 <code>CSS</code>、处理文本上不足，不容易被搜索</p> <p><code>Ajax</code>：<br>
（1） <code>Ajax</code> 对 <code>CSS</code>、文本支持很好，支持搜索<br>
（2） 多媒体、矢量图形、机器访问不足</p> <p>共同点：<br>
（1） 与服务器的无刷新传递消息<br>
（2） 可以检测用户离线和在线状态<br>
（3） 操作 <code>DOM</code></p> <h2 id="css-reset-和-normalize-css-有什么区别"><a href="#css-reset-和-normalize-css-有什么区别" class="header-anchor">#</a> css reset 和 normalize.css 有什么区别？</h2> <p><code>css reset</code> 是最早的一种解决浏览器间样式不兼容问题的方案，它的基本思想是将浏览器的所有样式都重置掉，从而达到所有浏览器样式保持一致的效果。但是使用这种方法，可能会带来一些性能上的问题，并且对于一些元素的不必要的样式的重置，其实反而会造成画蛇添足的效果。</p> <p>后面出现一种更好的解决浏览器间样式不兼容的方法，就是 <code>normalize.css</code> ，它的思想是尽量的保留浏览器自带的样式，通过在原有的样式的基础上进行调整，来保持各个浏览器间的样式表现一致。相对与 <code>css reset</code>，<code>normalize.css</code> 的方法保留了有价值的默认值，并且修复了一些浏览器的 <code>bug</code>，而且使用 <code>normalize.css</code> 不会造成元素复杂的继承链。</p> <h2 id="dhtml-是什么"><a href="#dhtml-是什么" class="header-anchor">#</a> DHTML 是什么？</h2> <p><code>DHTML</code> 将 <code>HTML</code>、<code>JavaScript</code>、<code>DOM</code> 以及 <code>CSS</code> 组合在一起，用于创造动态性更强的网页。通过 <code>JavaScript</code> 和 <code>HTML DOM</code>，能够动态地改变 <code>HTML</code> 元素的样式。</p> <p><code>DHTML</code> 实现了网页从 <code>Web</code> 服务器下载后无需再经过服务的处理，而在浏览器中直接动态地更新网页的内容、排版样式和动画的功能。例如，当鼠标指针移到文章段落中时，段落能够变成蓝色，或者当鼠标指针移到一个超级链接上时，会自动生成一个下拉式子链接目录等。</p> <p>包括：<br>
（1）<code>动态内容（Dynamic Content）</code>：动态地更新网页内容，可“动态”地插入、修改或删除网页的元件，如文字、图像、标记等。</p> <p>（2）<code>动态排版样式（Dynamic Style Sheets）</code>：<code>W3C</code> 的 <code>CSS</code> 样式表提供了设定 <code>HTML</code> 标记的字体大小、字形、样式、粗细、文字颜色、行高度、加底线或加中间横线、缩排、与边缘距离、靠左右或置中、背景图片或颜色等排版功能，而“动态排版样式”即可以“动态”地改变排版样式。</p> <h2 id="head-标签中必不少的是"><a href="#head-标签中必不少的是" class="header-anchor">#</a> head 标签中必不少的是？</h2> <p><code>&lt;head&gt;</code> 标签用于定义文档的头部，它是所有头部元素的容器。<code>&lt;head&gt;</code> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。</p> <p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 <code>Web</code> 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p> <p>下面这些标签可用在 head 部分：<code>&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, 以及 &lt;title&gt;</code>。</p> <p><code>&lt;title&gt;</code> 定义文档的标题，它是 <code>head</code> 部分中唯一必需的元素。</p> <h2 id="html5-新增的表单元素有"><a href="#html5-新增的表单元素有" class="header-anchor">#</a> HTML5 新增的表单元素有？</h2> <p><code>datalist</code> 规定输入域的选项列表，通过 <code>option</code> 创建！</p> <p><code>keygen</code> 提供一种验证用户的可靠方法，密钥对生成器，私钥存于客户端，公钥发到服务器，用于之后验证客户端证书！</p> <p><code>output</code> 元素用于不同类型的输出！</p> <h2 id="在-html5-中-哪个方法用于获得用户的当前位置"><a href="#在-html5-中-哪个方法用于获得用户的当前位置" class="header-anchor">#</a> 在 HTML5 中，哪个方法用于获得用户的当前位置？</h2> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token function">getCurrentPosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="disabled-和-readonly-的区别"><a href="#disabled-和-readonly-的区别" class="header-anchor">#</a> disabled 和 readonly 的区别？</h2> <p><code>disabled</code> 指当 <code>input</code> 元素加载时禁用此元素。<code>input</code> 内容不会随着表单提交。</p> <p><code>readonly</code> 规定输入字段为只读。<code>input</code> 内容会随着表单提交。</p> <p>无论设置 <code>readonly</code> 还是 <code>disabled</code>，通过 <code>js</code>脚本都能更改 <code>input</code> 的 <code>value</code></p> <h2 id="前端性能优化"><a href="#前端性能优化" class="header-anchor">#</a> 前端性能优化？</h2> <p>前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。</p> <p>第一个方面是页面的内容方面<br>
（1）通过<code>文件合并</code>、<code>css 雪碧图</code>、使用 <code>base64</code> 等方式来减少 <code>HTTP</code> 请求数，避免过多的请求造成等待的情况。<br>
（2）通过 <code>DNS</code> 缓存等机制来减少 <code>DNS</code> 的查询次数。<br>
（3）通过设置缓存策略，对常用不变的资源进行缓存。<br>
（4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。<br>
（5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。</p> <p>第二个方面是服务器方面<br>
（1）使用 <code>CDN</code> 服务，来提高用户对于资源请求时的响应速度。<br>
（2）服务器端启用 <code>Gzip</code>、<code>Deflate</code> 等方式对于传输的资源进行压缩，减小文件的体积。<br>
（3）尽可能减小 <code>cookie</code> 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 <code>cookie</code></p> <p>第三个方面是 <code>CSS</code> 和 <code>JavaScript</code> 方面<br>
（1）把样式表放在页面的 <code>head 标签</code>中，减少页面的首次渲染的时间。<br>
（2）避免使用 <code>@import</code> 标签。<br>
（3）尽量把 <code>js</code> 脚本放在页面底部或者使用 <code>defer</code> 或 <code>async</code> 属性，避免脚本的加载和执行阻塞页面的渲染。<br>
（4）通过对 <code>JavaScript</code> 和 <code>CSS</code> 的文件进行压缩，来减小文件的体积。</p> <h2 id="扫描二维码登录网页是什么原理-前后两个事件是如何联系的"><a href="#扫描二维码登录网页是什么原理-前后两个事件是如何联系的" class="header-anchor">#</a> 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？</h2> <p>核心过程应该是：浏览器获得一个临时 <code>id</code>，通过长连接等待客户端扫描带有此 <code>id</code> 的二维码后，从长连接中获得客户端上报给 <code>server</code>的帐号信息进行展示。并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。</p> <p>二维码登录网页的基本原理是，用户进入登录网页后，服务器生成一个 <code>uid</code> 来标识一个用户。对应的二维码对应了一个对应 <code>uid</code> 的链接，任何能够识别二维码的应用都可以获得这个链接，但是它们没有办法和对应登录的服务器响应。比如微信的二维码登录，只有用微信识这个二维码才有效。当微信客户端打开这个链接时，对应的登录服务器就获得了用户的相关信息。这个时候登录网页根据先前的长连接获取到服务器传过来的用户信息进行显示。然后提前预加载一些登录后可能用到的信息。当客户端点击确认授权登陆后，服务器生成一个权限令牌给网页，网页之后使用这个令牌进行信息的交互过程。由于整个授权的过程都是在手机端进行的，因此能够很好的防止 PC 上泛滥的病毒。并且在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程能够形成有效的安全防护。</p> <h2 id="html-规范中为什么要求引用资源不加协议头http或者https"><a href="#html-规范中为什么要求引用资源不加协议头http或者https" class="header-anchor">#</a> Html 规范中为什么要求引用资源不加协议头http或者https？</h2> <p>如果用户当前访问的页面是通过 <code>HTTPS</code> 协议来浏览的，那么网页中的资源也只能通过 <code>HTTPS</code> 协议来引用，否则浏览器会出现警告信息，不同浏览器警告信息展现形式不同。</p> <p>为了解决这个问题，我们可以省略 <code>URL</code> 的协议声明，省略后浏览器照样可以正常引用相应的资源，这项解决方案称为
<code>protocol-relative URL</code>，暂且可译作协议相对 <code>URL</code>。</p> <p>如果使用协议相对 <code>URL</code>，无论是使用 <code>HTTPS</code>，还是 <code>HTTP</code> 访问页面，浏览器都会以相同的协议请求页面中的资源，避免弹出类似的警告信息，同时还可以节省<code>5字节</code>的数据量。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">3/17/2021, 5:31:38 PM</span></div></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/weblog/assets/js/app.eefccb8e.js" defer></script><script src="/weblog/assets/js/2.dbfb7c6a.js" defer></script><script src="/weblog/assets/js/37.580f62e9.js" defer></script>
  </body>
</html>
